{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst errors_1 = require(\"@oclif/errors\");\n\nconst errors_2 = require(\"./errors\");\n\nfunction validate(parse) {\n  function validateArgs() {\n    const maxArgs = parse.input.args.length;\n\n    if (parse.input.strict && parse.output.argv.length > maxArgs) {\n      const extras = parse.output.argv.slice(maxArgs);\n      throw new errors_2.UnexpectedArgsError({\n        parse,\n        args: extras\n      });\n    }\n\n    const missingRequiredArgs = [];\n    let hasOptional = false;\n    parse.input.args.forEach((arg, index) => {\n      if (!arg.required) {\n        hasOptional = true;\n      } else if (hasOptional) {\n        // (required arg) check whether an optional has occured before\n        // optionals should follow required, not before\n        throw new errors_2.InvalidArgsSpecError({\n          parse,\n          args: parse.input.args\n        });\n      }\n\n      if (arg.required) {\n        if (!parse.output.argv[index]) {\n          missingRequiredArgs.push(arg);\n        }\n      }\n    });\n\n    if (missingRequiredArgs.length > 0) {\n      throw new errors_2.RequiredArgsError({\n        parse,\n        args: missingRequiredArgs\n      });\n    }\n  }\n\n  function validateFlags() {\n    for (const [name, flag] of Object.entries(parse.input.flags)) {\n      if (parse.output.flags[name] !== undefined) {\n        for (const also of flag.dependsOn || []) {\n          if (!parse.output.flags[also]) {\n            throw new errors_1.CLIError(`--${also}= must also be provided when using --${name}=`);\n          }\n        }\n\n        for (const also of flag.exclusive || []) {\n          // do not enforce exclusivity for flags that were defaulted\n          if (parse.output.metadata.flags[also] && parse.output.metadata.flags[also].setFromDefault) continue;\n          if (parse.output.metadata.flags[name] && parse.output.metadata.flags[name].setFromDefault) continue;\n\n          if (parse.output.flags[also]) {\n            throw new errors_1.CLIError(`--${also}= cannot also be provided when using --${name}=`);\n          }\n        }\n      } else if (flag.required) throw new errors_2.RequiredFlagError({\n        parse,\n        flag\n      });\n    }\n  }\n\n  validateArgs();\n  validateFlags();\n}\n\nexports.validate = validate;","map":{"version":3,"sources":["C:/Users/Mdp79/Desktop/04-Supplemental/giphtionary/node_modules/@oclif/parser/lib/validate.js"],"names":["Object","defineProperty","exports","value","errors_1","require","errors_2","validate","parse","validateArgs","maxArgs","input","args","length","strict","output","argv","extras","slice","UnexpectedArgsError","missingRequiredArgs","hasOptional","forEach","arg","index","required","InvalidArgsSpecError","push","RequiredArgsError","validateFlags","name","flag","entries","flags","undefined","also","dependsOn","CLIError","exclusive","metadata","setFromDefault","RequiredFlagError"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst errors_1 = require(\"@oclif/errors\");\nconst errors_2 = require(\"./errors\");\nfunction validate(parse) {\n    function validateArgs() {\n        const maxArgs = parse.input.args.length;\n        if (parse.input.strict && parse.output.argv.length > maxArgs) {\n            const extras = parse.output.argv.slice(maxArgs);\n            throw new errors_2.UnexpectedArgsError({ parse, args: extras });\n        }\n        const missingRequiredArgs = [];\n        let hasOptional = false;\n        parse.input.args.forEach((arg, index) => {\n            if (!arg.required) {\n                hasOptional = true;\n            }\n            else if (hasOptional) { // (required arg) check whether an optional has occured before\n                // optionals should follow required, not before\n                throw new errors_2.InvalidArgsSpecError({ parse, args: parse.input.args });\n            }\n            if (arg.required) {\n                if (!parse.output.argv[index]) {\n                    missingRequiredArgs.push(arg);\n                }\n            }\n        });\n        if (missingRequiredArgs.length > 0) {\n            throw new errors_2.RequiredArgsError({ parse, args: missingRequiredArgs });\n        }\n    }\n    function validateFlags() {\n        for (const [name, flag] of Object.entries(parse.input.flags)) {\n            if (parse.output.flags[name] !== undefined) {\n                for (const also of flag.dependsOn || []) {\n                    if (!parse.output.flags[also]) {\n                        throw new errors_1.CLIError(`--${also}= must also be provided when using --${name}=`);\n                    }\n                }\n                for (const also of flag.exclusive || []) {\n                    // do not enforce exclusivity for flags that were defaulted\n                    if (parse.output.metadata.flags[also] && parse.output.metadata.flags[also].setFromDefault)\n                        continue;\n                    if (parse.output.metadata.flags[name] && parse.output.metadata.flags[name].setFromDefault)\n                        continue;\n                    if (parse.output.flags[also]) {\n                        throw new errors_1.CLIError(`--${also}= cannot also be provided when using --${name}=`);\n                    }\n                }\n            }\n            else if (flag.required)\n                throw new errors_2.RequiredFlagError({ parse, flag });\n        }\n    }\n    validateArgs();\n    validateFlags();\n}\nexports.validate = validate;\n"]},"metadata":{},"sourceType":"script"}